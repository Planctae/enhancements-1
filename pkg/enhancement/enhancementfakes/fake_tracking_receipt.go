// Code generated by counterfeiter. DO NOT EDIT.
package enhancementfakes

import (
	sync "sync"

	enhancement "github.com/planctae/enhancements-tracking-ng/pkg/enhancement"
)

type FakeTrackingReceipt struct {
	AffectedSubprojectsStub        func() []string
	affectedSubprojectsMutex       sync.RWMutex
	affectedSubprojectsArgsForCall []struct {
	}
	affectedSubprojectsReturns struct {
		result1 []string
	}
	affectedSubprojectsReturnsOnCall map[int]struct {
		result1 []string
	}
	AuthorsStub        func() []string
	authorsMutex       sync.RWMutex
	authorsArgsForCall []struct {
	}
	authorsReturns struct {
		result1 []string
	}
	authorsReturnsOnCall map[int]struct {
		result1 []string
	}
	ContactEmailStub        func() string
	contactEmailMutex       sync.RWMutex
	contactEmailArgsForCall []struct {
	}
	contactEmailReturns struct {
		result1 string
	}
	contactEmailReturnsOnCall map[int]struct {
		result1 string
	}
	CurrentMaturityStub        func() string
	currentMaturityMutex       sync.RWMutex
	currentMaturityArgsForCall []struct {
	}
	currentMaturityReturns struct {
		result1 string
	}
	currentMaturityReturnsOnCall map[int]struct {
		result1 string
	}
	DocumentationLocationsStub        func() []string
	documentationLocationsMutex       sync.RWMutex
	documentationLocationsArgsForCall []struct {
	}
	documentationLocationsReturns struct {
		result1 []string
	}
	documentationLocationsReturnsOnCall map[int]struct {
		result1 []string
	}
	KEPLocationStub        func() string
	kEPLocationMutex       sync.RWMutex
	kEPLocationArgsForCall []struct {
	}
	kEPLocationReturns struct {
		result1 string
	}
	kEPLocationReturnsOnCall map[int]struct {
		result1 string
	}
	ReleaseNoteLocationStub        func() string
	releaseNoteLocationMutex       sync.RWMutex
	releaseNoteLocationArgsForCall []struct {
	}
	releaseNoteLocationReturns struct {
		result1 string
	}
	releaseNoteLocationReturnsOnCall map[int]struct {
		result1 string
	}
	SponsoringSIGStub        func() string
	sponsoringSIGMutex       sync.RWMutex
	sponsoringSIGArgsForCall []struct {
	}
	sponsoringSIGReturns struct {
		result1 string
	}
	sponsoringSIGReturnsOnCall map[int]struct {
		result1 string
	}
	TargetMaturityStub        func() string
	targetMaturityMutex       sync.RWMutex
	targetMaturityArgsForCall []struct {
	}
	targetMaturityReturns struct {
		result1 string
	}
	targetMaturityReturnsOnCall map[int]struct {
		result1 string
	}
	TestLocationsStub        func() []string
	testLocationsMutex       sync.RWMutex
	testLocationsArgsForCall []struct {
	}
	testLocationsReturns struct {
		result1 []string
	}
	testLocationsReturnsOnCall map[int]struct {
		result1 []string
	}
	TitleStub        func() string
	titleMutex       sync.RWMutex
	titleArgsForCall []struct {
	}
	titleReturns struct {
		result1 string
	}
	titleReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTrackingReceipt) AffectedSubprojects() []string {
	fake.affectedSubprojectsMutex.Lock()
	ret, specificReturn := fake.affectedSubprojectsReturnsOnCall[len(fake.affectedSubprojectsArgsForCall)]
	fake.affectedSubprojectsArgsForCall = append(fake.affectedSubprojectsArgsForCall, struct {
	}{})
	fake.recordInvocation("AffectedSubprojects", []interface{}{})
	fake.affectedSubprojectsMutex.Unlock()
	if fake.AffectedSubprojectsStub != nil {
		return fake.AffectedSubprojectsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.affectedSubprojectsReturns
	return fakeReturns.result1
}

func (fake *FakeTrackingReceipt) AffectedSubprojectsCallCount() int {
	fake.affectedSubprojectsMutex.RLock()
	defer fake.affectedSubprojectsMutex.RUnlock()
	return len(fake.affectedSubprojectsArgsForCall)
}

func (fake *FakeTrackingReceipt) AffectedSubprojectsCalls(stub func() []string) {
	fake.affectedSubprojectsMutex.Lock()
	defer fake.affectedSubprojectsMutex.Unlock()
	fake.AffectedSubprojectsStub = stub
}

func (fake *FakeTrackingReceipt) AffectedSubprojectsReturns(result1 []string) {
	fake.affectedSubprojectsMutex.Lock()
	defer fake.affectedSubprojectsMutex.Unlock()
	fake.AffectedSubprojectsStub = nil
	fake.affectedSubprojectsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeTrackingReceipt) AffectedSubprojectsReturnsOnCall(i int, result1 []string) {
	fake.affectedSubprojectsMutex.Lock()
	defer fake.affectedSubprojectsMutex.Unlock()
	fake.AffectedSubprojectsStub = nil
	if fake.affectedSubprojectsReturnsOnCall == nil {
		fake.affectedSubprojectsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.affectedSubprojectsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeTrackingReceipt) Authors() []string {
	fake.authorsMutex.Lock()
	ret, specificReturn := fake.authorsReturnsOnCall[len(fake.authorsArgsForCall)]
	fake.authorsArgsForCall = append(fake.authorsArgsForCall, struct {
	}{})
	fake.recordInvocation("Authors", []interface{}{})
	fake.authorsMutex.Unlock()
	if fake.AuthorsStub != nil {
		return fake.AuthorsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.authorsReturns
	return fakeReturns.result1
}

func (fake *FakeTrackingReceipt) AuthorsCallCount() int {
	fake.authorsMutex.RLock()
	defer fake.authorsMutex.RUnlock()
	return len(fake.authorsArgsForCall)
}

func (fake *FakeTrackingReceipt) AuthorsCalls(stub func() []string) {
	fake.authorsMutex.Lock()
	defer fake.authorsMutex.Unlock()
	fake.AuthorsStub = stub
}

func (fake *FakeTrackingReceipt) AuthorsReturns(result1 []string) {
	fake.authorsMutex.Lock()
	defer fake.authorsMutex.Unlock()
	fake.AuthorsStub = nil
	fake.authorsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeTrackingReceipt) AuthorsReturnsOnCall(i int, result1 []string) {
	fake.authorsMutex.Lock()
	defer fake.authorsMutex.Unlock()
	fake.AuthorsStub = nil
	if fake.authorsReturnsOnCall == nil {
		fake.authorsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.authorsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeTrackingReceipt) ContactEmail() string {
	fake.contactEmailMutex.Lock()
	ret, specificReturn := fake.contactEmailReturnsOnCall[len(fake.contactEmailArgsForCall)]
	fake.contactEmailArgsForCall = append(fake.contactEmailArgsForCall, struct {
	}{})
	fake.recordInvocation("ContactEmail", []interface{}{})
	fake.contactEmailMutex.Unlock()
	if fake.ContactEmailStub != nil {
		return fake.ContactEmailStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.contactEmailReturns
	return fakeReturns.result1
}

func (fake *FakeTrackingReceipt) ContactEmailCallCount() int {
	fake.contactEmailMutex.RLock()
	defer fake.contactEmailMutex.RUnlock()
	return len(fake.contactEmailArgsForCall)
}

func (fake *FakeTrackingReceipt) ContactEmailCalls(stub func() string) {
	fake.contactEmailMutex.Lock()
	defer fake.contactEmailMutex.Unlock()
	fake.ContactEmailStub = stub
}

func (fake *FakeTrackingReceipt) ContactEmailReturns(result1 string) {
	fake.contactEmailMutex.Lock()
	defer fake.contactEmailMutex.Unlock()
	fake.ContactEmailStub = nil
	fake.contactEmailReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTrackingReceipt) ContactEmailReturnsOnCall(i int, result1 string) {
	fake.contactEmailMutex.Lock()
	defer fake.contactEmailMutex.Unlock()
	fake.ContactEmailStub = nil
	if fake.contactEmailReturnsOnCall == nil {
		fake.contactEmailReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.contactEmailReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTrackingReceipt) CurrentMaturity() string {
	fake.currentMaturityMutex.Lock()
	ret, specificReturn := fake.currentMaturityReturnsOnCall[len(fake.currentMaturityArgsForCall)]
	fake.currentMaturityArgsForCall = append(fake.currentMaturityArgsForCall, struct {
	}{})
	fake.recordInvocation("CurrentMaturity", []interface{}{})
	fake.currentMaturityMutex.Unlock()
	if fake.CurrentMaturityStub != nil {
		return fake.CurrentMaturityStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.currentMaturityReturns
	return fakeReturns.result1
}

func (fake *FakeTrackingReceipt) CurrentMaturityCallCount() int {
	fake.currentMaturityMutex.RLock()
	defer fake.currentMaturityMutex.RUnlock()
	return len(fake.currentMaturityArgsForCall)
}

func (fake *FakeTrackingReceipt) CurrentMaturityCalls(stub func() string) {
	fake.currentMaturityMutex.Lock()
	defer fake.currentMaturityMutex.Unlock()
	fake.CurrentMaturityStub = stub
}

func (fake *FakeTrackingReceipt) CurrentMaturityReturns(result1 string) {
	fake.currentMaturityMutex.Lock()
	defer fake.currentMaturityMutex.Unlock()
	fake.CurrentMaturityStub = nil
	fake.currentMaturityReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTrackingReceipt) CurrentMaturityReturnsOnCall(i int, result1 string) {
	fake.currentMaturityMutex.Lock()
	defer fake.currentMaturityMutex.Unlock()
	fake.CurrentMaturityStub = nil
	if fake.currentMaturityReturnsOnCall == nil {
		fake.currentMaturityReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.currentMaturityReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTrackingReceipt) DocumentationLocations() []string {
	fake.documentationLocationsMutex.Lock()
	ret, specificReturn := fake.documentationLocationsReturnsOnCall[len(fake.documentationLocationsArgsForCall)]
	fake.documentationLocationsArgsForCall = append(fake.documentationLocationsArgsForCall, struct {
	}{})
	fake.recordInvocation("DocumentationLocations", []interface{}{})
	fake.documentationLocationsMutex.Unlock()
	if fake.DocumentationLocationsStub != nil {
		return fake.DocumentationLocationsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.documentationLocationsReturns
	return fakeReturns.result1
}

func (fake *FakeTrackingReceipt) DocumentationLocationsCallCount() int {
	fake.documentationLocationsMutex.RLock()
	defer fake.documentationLocationsMutex.RUnlock()
	return len(fake.documentationLocationsArgsForCall)
}

func (fake *FakeTrackingReceipt) DocumentationLocationsCalls(stub func() []string) {
	fake.documentationLocationsMutex.Lock()
	defer fake.documentationLocationsMutex.Unlock()
	fake.DocumentationLocationsStub = stub
}

func (fake *FakeTrackingReceipt) DocumentationLocationsReturns(result1 []string) {
	fake.documentationLocationsMutex.Lock()
	defer fake.documentationLocationsMutex.Unlock()
	fake.DocumentationLocationsStub = nil
	fake.documentationLocationsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeTrackingReceipt) DocumentationLocationsReturnsOnCall(i int, result1 []string) {
	fake.documentationLocationsMutex.Lock()
	defer fake.documentationLocationsMutex.Unlock()
	fake.DocumentationLocationsStub = nil
	if fake.documentationLocationsReturnsOnCall == nil {
		fake.documentationLocationsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.documentationLocationsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeTrackingReceipt) KEPLocation() string {
	fake.kEPLocationMutex.Lock()
	ret, specificReturn := fake.kEPLocationReturnsOnCall[len(fake.kEPLocationArgsForCall)]
	fake.kEPLocationArgsForCall = append(fake.kEPLocationArgsForCall, struct {
	}{})
	fake.recordInvocation("KEPLocation", []interface{}{})
	fake.kEPLocationMutex.Unlock()
	if fake.KEPLocationStub != nil {
		return fake.KEPLocationStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.kEPLocationReturns
	return fakeReturns.result1
}

func (fake *FakeTrackingReceipt) KEPLocationCallCount() int {
	fake.kEPLocationMutex.RLock()
	defer fake.kEPLocationMutex.RUnlock()
	return len(fake.kEPLocationArgsForCall)
}

func (fake *FakeTrackingReceipt) KEPLocationCalls(stub func() string) {
	fake.kEPLocationMutex.Lock()
	defer fake.kEPLocationMutex.Unlock()
	fake.KEPLocationStub = stub
}

func (fake *FakeTrackingReceipt) KEPLocationReturns(result1 string) {
	fake.kEPLocationMutex.Lock()
	defer fake.kEPLocationMutex.Unlock()
	fake.KEPLocationStub = nil
	fake.kEPLocationReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTrackingReceipt) KEPLocationReturnsOnCall(i int, result1 string) {
	fake.kEPLocationMutex.Lock()
	defer fake.kEPLocationMutex.Unlock()
	fake.KEPLocationStub = nil
	if fake.kEPLocationReturnsOnCall == nil {
		fake.kEPLocationReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.kEPLocationReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTrackingReceipt) ReleaseNoteLocation() string {
	fake.releaseNoteLocationMutex.Lock()
	ret, specificReturn := fake.releaseNoteLocationReturnsOnCall[len(fake.releaseNoteLocationArgsForCall)]
	fake.releaseNoteLocationArgsForCall = append(fake.releaseNoteLocationArgsForCall, struct {
	}{})
	fake.recordInvocation("ReleaseNoteLocation", []interface{}{})
	fake.releaseNoteLocationMutex.Unlock()
	if fake.ReleaseNoteLocationStub != nil {
		return fake.ReleaseNoteLocationStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.releaseNoteLocationReturns
	return fakeReturns.result1
}

func (fake *FakeTrackingReceipt) ReleaseNoteLocationCallCount() int {
	fake.releaseNoteLocationMutex.RLock()
	defer fake.releaseNoteLocationMutex.RUnlock()
	return len(fake.releaseNoteLocationArgsForCall)
}

func (fake *FakeTrackingReceipt) ReleaseNoteLocationCalls(stub func() string) {
	fake.releaseNoteLocationMutex.Lock()
	defer fake.releaseNoteLocationMutex.Unlock()
	fake.ReleaseNoteLocationStub = stub
}

func (fake *FakeTrackingReceipt) ReleaseNoteLocationReturns(result1 string) {
	fake.releaseNoteLocationMutex.Lock()
	defer fake.releaseNoteLocationMutex.Unlock()
	fake.ReleaseNoteLocationStub = nil
	fake.releaseNoteLocationReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTrackingReceipt) ReleaseNoteLocationReturnsOnCall(i int, result1 string) {
	fake.releaseNoteLocationMutex.Lock()
	defer fake.releaseNoteLocationMutex.Unlock()
	fake.ReleaseNoteLocationStub = nil
	if fake.releaseNoteLocationReturnsOnCall == nil {
		fake.releaseNoteLocationReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.releaseNoteLocationReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTrackingReceipt) SponsoringSIG() string {
	fake.sponsoringSIGMutex.Lock()
	ret, specificReturn := fake.sponsoringSIGReturnsOnCall[len(fake.sponsoringSIGArgsForCall)]
	fake.sponsoringSIGArgsForCall = append(fake.sponsoringSIGArgsForCall, struct {
	}{})
	fake.recordInvocation("SponsoringSIG", []interface{}{})
	fake.sponsoringSIGMutex.Unlock()
	if fake.SponsoringSIGStub != nil {
		return fake.SponsoringSIGStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sponsoringSIGReturns
	return fakeReturns.result1
}

func (fake *FakeTrackingReceipt) SponsoringSIGCallCount() int {
	fake.sponsoringSIGMutex.RLock()
	defer fake.sponsoringSIGMutex.RUnlock()
	return len(fake.sponsoringSIGArgsForCall)
}

func (fake *FakeTrackingReceipt) SponsoringSIGCalls(stub func() string) {
	fake.sponsoringSIGMutex.Lock()
	defer fake.sponsoringSIGMutex.Unlock()
	fake.SponsoringSIGStub = stub
}

func (fake *FakeTrackingReceipt) SponsoringSIGReturns(result1 string) {
	fake.sponsoringSIGMutex.Lock()
	defer fake.sponsoringSIGMutex.Unlock()
	fake.SponsoringSIGStub = nil
	fake.sponsoringSIGReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTrackingReceipt) SponsoringSIGReturnsOnCall(i int, result1 string) {
	fake.sponsoringSIGMutex.Lock()
	defer fake.sponsoringSIGMutex.Unlock()
	fake.SponsoringSIGStub = nil
	if fake.sponsoringSIGReturnsOnCall == nil {
		fake.sponsoringSIGReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.sponsoringSIGReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTrackingReceipt) TargetMaturity() string {
	fake.targetMaturityMutex.Lock()
	ret, specificReturn := fake.targetMaturityReturnsOnCall[len(fake.targetMaturityArgsForCall)]
	fake.targetMaturityArgsForCall = append(fake.targetMaturityArgsForCall, struct {
	}{})
	fake.recordInvocation("TargetMaturity", []interface{}{})
	fake.targetMaturityMutex.Unlock()
	if fake.TargetMaturityStub != nil {
		return fake.TargetMaturityStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.targetMaturityReturns
	return fakeReturns.result1
}

func (fake *FakeTrackingReceipt) TargetMaturityCallCount() int {
	fake.targetMaturityMutex.RLock()
	defer fake.targetMaturityMutex.RUnlock()
	return len(fake.targetMaturityArgsForCall)
}

func (fake *FakeTrackingReceipt) TargetMaturityCalls(stub func() string) {
	fake.targetMaturityMutex.Lock()
	defer fake.targetMaturityMutex.Unlock()
	fake.TargetMaturityStub = stub
}

func (fake *FakeTrackingReceipt) TargetMaturityReturns(result1 string) {
	fake.targetMaturityMutex.Lock()
	defer fake.targetMaturityMutex.Unlock()
	fake.TargetMaturityStub = nil
	fake.targetMaturityReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTrackingReceipt) TargetMaturityReturnsOnCall(i int, result1 string) {
	fake.targetMaturityMutex.Lock()
	defer fake.targetMaturityMutex.Unlock()
	fake.TargetMaturityStub = nil
	if fake.targetMaturityReturnsOnCall == nil {
		fake.targetMaturityReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.targetMaturityReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTrackingReceipt) TestLocations() []string {
	fake.testLocationsMutex.Lock()
	ret, specificReturn := fake.testLocationsReturnsOnCall[len(fake.testLocationsArgsForCall)]
	fake.testLocationsArgsForCall = append(fake.testLocationsArgsForCall, struct {
	}{})
	fake.recordInvocation("TestLocations", []interface{}{})
	fake.testLocationsMutex.Unlock()
	if fake.TestLocationsStub != nil {
		return fake.TestLocationsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.testLocationsReturns
	return fakeReturns.result1
}

func (fake *FakeTrackingReceipt) TestLocationsCallCount() int {
	fake.testLocationsMutex.RLock()
	defer fake.testLocationsMutex.RUnlock()
	return len(fake.testLocationsArgsForCall)
}

func (fake *FakeTrackingReceipt) TestLocationsCalls(stub func() []string) {
	fake.testLocationsMutex.Lock()
	defer fake.testLocationsMutex.Unlock()
	fake.TestLocationsStub = stub
}

func (fake *FakeTrackingReceipt) TestLocationsReturns(result1 []string) {
	fake.testLocationsMutex.Lock()
	defer fake.testLocationsMutex.Unlock()
	fake.TestLocationsStub = nil
	fake.testLocationsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeTrackingReceipt) TestLocationsReturnsOnCall(i int, result1 []string) {
	fake.testLocationsMutex.Lock()
	defer fake.testLocationsMutex.Unlock()
	fake.TestLocationsStub = nil
	if fake.testLocationsReturnsOnCall == nil {
		fake.testLocationsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.testLocationsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeTrackingReceipt) Title() string {
	fake.titleMutex.Lock()
	ret, specificReturn := fake.titleReturnsOnCall[len(fake.titleArgsForCall)]
	fake.titleArgsForCall = append(fake.titleArgsForCall, struct {
	}{})
	fake.recordInvocation("Title", []interface{}{})
	fake.titleMutex.Unlock()
	if fake.TitleStub != nil {
		return fake.TitleStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.titleReturns
	return fakeReturns.result1
}

func (fake *FakeTrackingReceipt) TitleCallCount() int {
	fake.titleMutex.RLock()
	defer fake.titleMutex.RUnlock()
	return len(fake.titleArgsForCall)
}

func (fake *FakeTrackingReceipt) TitleCalls(stub func() string) {
	fake.titleMutex.Lock()
	defer fake.titleMutex.Unlock()
	fake.TitleStub = stub
}

func (fake *FakeTrackingReceipt) TitleReturns(result1 string) {
	fake.titleMutex.Lock()
	defer fake.titleMutex.Unlock()
	fake.TitleStub = nil
	fake.titleReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTrackingReceipt) TitleReturnsOnCall(i int, result1 string) {
	fake.titleMutex.Lock()
	defer fake.titleMutex.Unlock()
	fake.TitleStub = nil
	if fake.titleReturnsOnCall == nil {
		fake.titleReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.titleReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTrackingReceipt) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.affectedSubprojectsMutex.RLock()
	defer fake.affectedSubprojectsMutex.RUnlock()
	fake.authorsMutex.RLock()
	defer fake.authorsMutex.RUnlock()
	fake.contactEmailMutex.RLock()
	defer fake.contactEmailMutex.RUnlock()
	fake.currentMaturityMutex.RLock()
	defer fake.currentMaturityMutex.RUnlock()
	fake.documentationLocationsMutex.RLock()
	defer fake.documentationLocationsMutex.RUnlock()
	fake.kEPLocationMutex.RLock()
	defer fake.kEPLocationMutex.RUnlock()
	fake.releaseNoteLocationMutex.RLock()
	defer fake.releaseNoteLocationMutex.RUnlock()
	fake.sponsoringSIGMutex.RLock()
	defer fake.sponsoringSIGMutex.RUnlock()
	fake.targetMaturityMutex.RLock()
	defer fake.targetMaturityMutex.RUnlock()
	fake.testLocationsMutex.RLock()
	defer fake.testLocationsMutex.RUnlock()
	fake.titleMutex.RLock()
	defer fake.titleMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTrackingReceipt) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ enhancement.TrackingReceipt = new(FakeTrackingReceipt)
